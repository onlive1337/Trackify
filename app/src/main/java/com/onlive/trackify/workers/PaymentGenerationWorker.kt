package com.onlive.trackify.workers

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.onlive.trackify.data.database.AppDatabase
import com.onlive.trackify.data.model.BillingFrequency
import com.onlive.trackify.data.model.Payment
import com.onlive.trackify.data.model.PaymentStatus
import com.onlive.trackify.utils.NotificationHelper
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar
import java.util.Date

class PaymentGenerationWorker(
    appContext: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(appContext, workerParams) {

    private val database = AppDatabase.getDatabase(appContext)
    private val subscriptionDao = database.subscriptionDao()
    private val paymentDao = database.paymentDao()
    private val notificationHelper = NotificationHelper(appContext)
    private val TAG = "PaymentGeneration"

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "PaymentGenerationWorker запущен")

            val activeSubscriptions = subscriptionDao.getActiveSubscriptionsSync()
            var generatedCount = 0
            var skippedCount = 0
            var errorCount = 0

            for (subscription in activeSubscriptions) {
                try {
                    if (subscription.endDate != null && subscription.endDate.before(Date())) {
                        Log.d(TAG, "Подписка ${subscription.name} истекла, пропускаем")
                        skippedCount++
                        continue
                    }

                    val lastPayment = paymentDao.getLastPaymentForSubscriptionSync(subscription.subscriptionId)

                    val calendar = Calendar.getInstance()
                    val today = calendar.time

                    val lastPaymentDate = lastPayment?.date ?: subscription.startDate

                    val nextPaymentDate = calculateNextPaymentDate(lastPaymentDate, subscription.billingFrequency)

                    if (!isDateInFuture(nextPaymentDate, today) &&
                        !isPaymentAlreadyCreated(subscription.subscriptionId, nextPaymentDate)) {

                        val newPayment = Payment(
                            subscriptionId = subscription.subscriptionId,
                            amount = subscription.price,
                            date = nextPaymentDate,
                            status = PaymentStatus.PENDING,
                            autoGenerated = true,
                            notes = "Автоматически создан системой"
                        )

                        val paymentId = paymentDao.insert(newPayment)
                        generatedCount++

                        Log.d(TAG, "Создан платеж для ${subscription.name} на дату ${nextPaymentDate}, ID: $paymentId")

                        if (isSameDay(nextPaymentDate, today) || nextPaymentDate.before(today)) {
                            notificationHelper.showUpcomingPaymentNotification(subscription, 0)
                            Log.d(TAG, "Отправлено уведомление о платеже для ${subscription.name}")
                        }
                    } else {
                        skippedCount++
                        Log.d(TAG, "Платеж для ${subscription.name} не требуется или уже создан")
                    }
                } catch (e: Exception) {
                    errorCount++
                    Log.e(TAG, "Ошибка при обработке подписки ${subscription.name}: ${e.message}", e)
                }
            }

            Log.d(TAG, "PaymentGenerationWorker завершен: создано $generatedCount платежей, пропущено $skippedCount, ошибок $errorCount")
            Result.success()
        } catch (e: Exception) {
            Log.e(TAG, "Критическая ошибка в PaymentGenerationWorker: ${e.message}", e)
            Result.failure()
        }
    }

    private fun calculateNextPaymentDate(baseDate: Date, frequency: BillingFrequency): Date {
        val calendar = Calendar.getInstance()
        calendar.time = baseDate

        when (frequency) {
            BillingFrequency.MONTHLY -> calendar.add(Calendar.MONTH, 1)
            BillingFrequency.YEARLY -> calendar.add(Calendar.YEAR, 1)
        }

        return calendar.time
    }

    private suspend fun isPaymentAlreadyCreated(subscriptionId: Long, date: Date): Boolean {
        val calendar = Calendar.getInstance()
        calendar.time = date

        calendar.add(Calendar.DAY_OF_MONTH, -1)
        val startDate = calendar.time

        calendar.add(Calendar.DAY_OF_MONTH, 2)
        val endDate = calendar.time

        val paymentsInRange = paymentDao.getPaymentsForSubscriptionBetweenDatesSync(
            subscriptionId, startDate, endDate
        )

        return paymentsInRange.isNotEmpty()
    }

    private fun isDateInFuture(date: Date, referenceDate: Date): Boolean {
        return date.after(referenceDate)
    }

    private fun isSameDay(date1: Date, date2: Date): Boolean {
        val cal1 = Calendar.getInstance()
        val cal2 = Calendar.getInstance()
        cal1.time = date1
        cal2.time = date2

        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
    }
}