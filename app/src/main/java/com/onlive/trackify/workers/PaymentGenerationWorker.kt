package com.onlive.trackify.workers

import android.content.Context
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.WorkerParameters
import com.onlive.trackify.R
import com.onlive.trackify.data.database.AppDatabase
import com.onlive.trackify.data.model.BillingFrequency
import com.onlive.trackify.data.model.Payment
import com.onlive.trackify.data.model.PaymentStatus
import com.onlive.trackify.data.model.Subscription
import com.onlive.trackify.utils.NotificationHelper
import com.onlive.trackify.utils.PreferenceManager
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import java.util.Calendar
import java.util.Date

class PaymentGenerationWorker(
    appContext: Context,
    workerParams: WorkerParameters
) : CoroutineWorker(appContext, workerParams) {

    private val database = AppDatabase.getDatabase(appContext)
    private val subscriptionDao = database.subscriptionDao()
    private val paymentDao = database.paymentDao()
    private val notificationHelper = NotificationHelper(appContext)
    private val preferenceManager = PreferenceManager(appContext)
    private val TAG = "PaymentGeneration"

    override suspend fun doWork(): Result = withContext(Dispatchers.IO) {
        try {
            Log.d(TAG, "PaymentGenerationWorker started")

            val activeSubscriptions = subscriptionDao.getActiveSubscriptionsSync()
            if (activeSubscriptions.isEmpty()) {
                Log.d(TAG, "No active subscriptions to process")
                return@withContext Result.success()
            }

            var generatedCount = 0
            var skippedCount = 0
            var errorCount = 0

            for (subscription in activeSubscriptions) {
                try {
                    if (subscription.endDate != null && subscription.endDate.before(Date())) {
                        Log.d(TAG, "Subscription ${subscription.name} has expired, skipping")
                        skippedCount++
                        continue
                    }

                    val lastPayment = paymentDao.getLastPaymentForSubscriptionSync(subscription.subscriptionId)

                    val calendar = Calendar.getInstance()
                    val today = calendar.time

                    val lastPaymentDate = lastPayment?.date ?: subscription.startDate

                    val nextPaymentDate = calculateNextPaymentDate(lastPaymentDate, subscription.billingFrequency)

                    if (!isDateInFuture(nextPaymentDate, today) &&
                        !isPaymentAlreadyCreated(subscription.subscriptionId, nextPaymentDate)) {

                        val newPayment = Payment(
                            subscriptionId = subscription.subscriptionId,
                            amount = subscription.price,
                            date = nextPaymentDate,
                            status = PaymentStatus.PENDING,
                            autoGenerated = true,
                            notes = applicationContext.getString(R.string.payment_auto_generated)
                        )

                        val paymentId = paymentDao.insert(newPayment)
                        generatedCount++

                        Log.d(TAG, "Created payment for ${subscription.name} on date ${nextPaymentDate}, ID: $paymentId")

                        if (preferenceManager.areNotificationsEnabled() &&
                            (isSameDay(nextPaymentDate, today) || nextPaymentDate.before(today))) {
                            notificationHelper.showUpcomingPaymentNotification(subscription, 0)
                            Log.d(TAG, "Sent payment notification for ${subscription.name}")
                        }
                    } else {
                        skippedCount++
                        Log.d(TAG, "Payment for ${subscription.name} not needed or already exists")
                    }

                    generateFuturePayments(subscription)

                } catch (e: Exception) {
                    errorCount++
                    Log.e(TAG, "Error processing subscription ${subscription.name}: ${e.message}", e)
                }
            }

            Log.d(TAG, "PaymentGenerationWorker finished: created $generatedCount payments, skipped $skippedCount, errors $errorCount")
            Result.success()
        } catch (e: Exception) {
            Log.e(TAG, "Critical error in PaymentGenerationWorker: ${e.message}", e)
            Result.failure()
        }
    }

    private suspend fun generateFuturePayments(subscription: Subscription) {
        try {
            val lastPayment = paymentDao.getLastPaymentForSubscriptionSync(subscription.subscriptionId)

            if (lastPayment == null) {
                Log.d(TAG, "No payments for ${subscription.name}, skipping future payment generation")
                return
            }

            var baseDate = lastPayment.date

            for (i in 1..3) {
                val futurePaymentDate = calculateNextPaymentDate(baseDate, subscription.billingFrequency)

                if (subscription.endDate != null && futurePaymentDate.after(subscription.endDate)) {
                    Log.d(TAG, "Future payment ${i} for ${subscription.name} exceeds subscription end date")
                    break
                }

                if (!isPaymentAlreadyCreated(subscription.subscriptionId, futurePaymentDate)) {
                    val futurePayment = Payment(
                        subscriptionId = subscription.subscriptionId,
                        amount = subscription.price,
                        date = futurePaymentDate,
                        status = PaymentStatus.PENDING,
                        autoGenerated = true,
                        notes = "${applicationContext.getString(R.string.payment_auto_generated)} (future)"
                    )

                    paymentDao.insert(futurePayment)
                    Log.d(TAG, "Created future payment #${i} for ${subscription.name} on date ${futurePaymentDate}")
                } else {
                    Log.d(TAG, "Future payment #${i} for ${subscription.name} already exists")
                }

                baseDate = futurePaymentDate
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error generating future payments for ${subscription.name}: ${e.message}", e)
        }
    }

    private fun calculateNextPaymentDate(baseDate: Date, frequency: BillingFrequency): Date {
        val calendar = Calendar.getInstance()
        calendar.time = baseDate

        when (frequency) {
            BillingFrequency.MONTHLY -> calendar.add(Calendar.MONTH, 1)
            BillingFrequency.YEARLY -> calendar.add(Calendar.YEAR, 1)
        }

        return calendar.time
    }

    private suspend fun isPaymentAlreadyCreated(subscriptionId: Long, date: Date): Boolean {
        val calendar = Calendar.getInstance()
        calendar.time = date

        calendar.add(Calendar.DAY_OF_MONTH, -1)
        val startDate = calendar.time

        calendar.add(Calendar.DAY_OF_MONTH, 2)
        val endDate = calendar.time

        val paymentsInRange = paymentDao.getPaymentsForSubscriptionBetweenDatesSync(
            subscriptionId, startDate, endDate
        )

        return paymentsInRange.isNotEmpty()
    }

    private fun isDateInFuture(date: Date, referenceDate: Date): Boolean {
        return date.after(referenceDate)
    }

    private fun isSameDay(date1: Date, date2: Date): Boolean {
        val cal1 = Calendar.getInstance()
        val cal2 = Calendar.getInstance()
        cal1.time = date1
        cal2.time = date2

        return cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&
                cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR)
    }
}